# Shlomi Ben-Shushan 311408264


from random import random, randint, shuffle, sample, choice
from copy import deepcopy
from matplotlib import pyplot as plt

fitness_calls = 0


class Futoshiki:

    def __init__(self, mat_size, given_digits, relations):
        self.dim = mat_size
        self.matrix = [[0 for j in range(mat_size)] for i in range(mat_size)]
        self.given_digits = {(i - 1, j - 1): v for i, j, v in given_digits}
        for i, j in self.given_digits.keys():
            self.matrix[i][j] = self.given_digits[(i, j)]
        self.sol_size = mat_size * mat_size - len(given_digits)
        self.relations = [(a - 1, b - 1, c - 1, d - 1) for (a, b, c, d) in relations]
        self.n_constraints = 2 * mat_size * mat_size + len(relations)

    def set(self, solution):
        k = 0
        for i in range(self.dim):
            for j in range(self.dim):
                if (i, j) not in self.given_digits.keys():
                    self.matrix[i][j] = solution[k]
                    k += 1

    def validate(self, solution):
        self.set(solution)
        for x in range(self.dim):
            for y in range(self.dim):
                v = self.matrix[x][y]
                for i in range(self.dim):
                    if i != x and self.matrix[i][y] == v:
                        return False
                for j in range(self.dim):
                    if j != y and self.matrix[x][j] == v:
                        return False
                for a, b, c, d in self.relations:
                    if (x, y) == (a, b) and self.matrix[x][y] <= self.matrix[c][d]:
                        return False
        return True

    def reset(self):
        for i in range(self.dim):
            for j in range(self.dim):
                if (i, j) not in self.given_digits.keys():
                    self.matrix[i][j] = 0


# def mutate(solution, mut_params, dim):
#     prob, rate = mut_params
#     if random() <= prob:
#         indexes = [i for i in range(len(solution))]
#         chosen = sample(indexes, int(rate * len(solution)))
#         for i in chosen:
#             solution[i] = randint(1, dim)
#     return solution
def mutate(solution, rate, dim):
    indexes = [i for i in range(len(solution))]
    chosen = sample(indexes, int(rate * len(solution)))
    for i in chosen:
        solution[i] = randint(1, dim)
    return solution


def cross_over(solution1, solution2):
    sep = randint(0, len(solution1) - 1)
    return solution1[:sep] + solution2[sep:]


def fitness(game, solution):
    global fitness_calls
    fitness_calls += 1
    game.set(solution)
    score = game.n_constraints
    for x in range(game.dim):
        for y in range(game.dim):
            v = game.matrix[x][y]
            for i in range(game.dim):
                if i != x and game.matrix[i][y] == v:
                    score -= 1
                    break
            for j in range(game.dim):
                if j != y and game.matrix[x][j] == v:
                    score -= 1
                    break
    for a, b, c, d in game.relations:
        if game.matrix[a][b] <= game.matrix[c][d]:
            score -= 1
    return score


# def fitness(game, solution):
#     global fitness_calls
#     fitness_calls += 1
#     game.set(solution)
#     score = 0
#     c = 1
#     for x in range(game.dim):
#         for y in range(game.dim):
#             if (x, y) in game.given_digits:
#                 continue
#             v = game.matrix[x][y]
#             for i in range(game.dim):
#                 if i == x:
#                     continue
#                 if game.matrix[i][y] != v:
#                     score += c
#                     c += 0.2
#             for j in range(game.dim):
#                 if j == y:
#                     continue
#                 if game.matrix[x][j] != v:
#                     score += c
#                     c += 0.2
#     for a, b, c, d in game.relations:
#         if game.matrix[a][b] > game.matrix[c][d]:
#             score += c
#             c += 0.2
#     return int(score)


def genetic_solver(game, generations, pop_size, elitism, crossover, mutation):
    # Constants
    n_elite = int(elitism * pop_size)
    n_newborns = int(crossover * pop_size)
    n_survivors = pop_size - n_elite - n_newborns
    r_mutate, p_mutate = mutation

    # Population
    population = []
    for i in range(pop_size):
        population.append([randint(1, game.dim) for j in range(game.sol_size)])

    # Statistics
    min_fitness = []
    avg_fitness = []
    max_fitness = []
    min_since_converged = []
    global fitness_calls
    fitness_calls = 0

    # Evolution
    chosen = None
    for g in range(generations):

        # Evaluation
        fitness_values = [fitness(game, s) for s in population]
        maximum = max(fitness_values)
        minimum = min(fitness_values)
        average = sum(fitness_values) / pop_size
        min_fitness.append(minimum)
        min_since_converged.append(minimum)
        max_fitness.append(maximum)
        avg_fitness.append(average)
        if (g + 1) % 10 == 0:
            print(f'Generation {g + 1}: Best fitness: {maximum} | Worst '
                  f'fitness: {minimum} | Average fitness: {average} | Fitness '
                  f'calls: {fitness_calls}')

        # Sort solutions according to fitness and mark chosen one.
        tuples = [(s, f) for s, f in zip(population, fitness_values)]
        tuples.sort(key=lambda tup: tup[1], reverse=True)
        chosen = deepcopy(tuples[0])

        # Convergence test
        if maximum == game.n_constraints:
            break
        if maximum == minimum:
            print('CONVERGED!')
            min_since_converged.clear()
            for i in range(1, pop_size):
                ns = [randint(1, game.dim) for j in range(game.sol_size)]
                tuples[i] = (ns, fitness(game, ns))
        else:
            r_mutate = mutation[0]

        # Make bias array
        bias_array = []
        for i, (s, f) in zip(range(len(tuples)), tuples):
            for j in range(f):
                bias_array.append(i)
        shuffle(bias_array)

        # Elitism
        elites = [s.copy() for s, f in tuples[:n_elite]]

        # Cross-over
        newborns = []
        while len(newborns) < n_newborns:
            i, j = sample(bias_array, 2)
            (si, fi), (sj, fj) = tuples[i], tuples[j]
            s = cross_over(si, sj)
            f = fitness(game, s)
            if maximum == minimum or f > max(min_since_converged):
                newborns.append((s, f))

        # Replication
        survivors = []
        while len(survivors) < n_survivors:
            i = choice(bias_array)
            survivors.append(tuples[i])
            bias_array = list(filter(lambda k: k != i, bias_array))

        # Mutation
        non_elites = survivors + newborns
        mutated = []
        for s, fs in non_elites:
            m = mutate(s.copy(), r_mutate, game.dim)
            if fitness(game, m) > fs:
                mutated.append(m)
            else:
                mutated.append(m if random() < p_mutate else s)

        # Create next generation
        population = elites + mutated

    # Plot
    plt.figure()
    plt.title('Fitness per generation')
    plt.xlabel('Generation')
    plt.ylabel('Fitness')
    x = list(range(len(min_fitness)))
    plt.plot(x, min_fitness, label='Minimal fitness')
    plt.plot(x, max_fitness, label='Maximal fitness')
    plt.plot(x, avg_fitness, label='Average fitness')
    plt.legend()
    plt.show()

    return chosen


# def calibrate(game):
#     generations = 300
#     pop_sizes = 100
#     elitism = [i * 0.05 for i in range(11)]
#     mutation = [(p * 0.5, r) for p in range(20) for r in [0.05, 0.1, 0.15]]
#     crossover = [i * 0.05 for i in range(20)]
#     thresholds = 1
#     params = []
#     total = len(elitism) * len(mutation) * len(crossover)
#     p = 0
#     for a in elitism:
#         for b in mutation:
#             for c in crossover:
#                 s, _ = genetic_solver(game, 300, 100, a, b, c, 1)
#                 f = fitness(game, s)
#                 p += 1
#                 if f > 50:
#                     print(f'Process: {p} / {total} \t Score: {f} \t elitism: {a}, mutation: {b}, crossover: {c}')


def convergence_handler(game, generations, pop_size, elitism, crossover, mutation):
    solutions = []
    for t in range(10):
        tup = genetic_solver(game, generations, pop_size, elitism, crossover, mutation)
        solutions.append(tup)
    return max(solutions, key=lambda tup: tup[1])[0]


def main():
    game = Futoshiki(mat_size=5,
                     given_digits=[(1, 2, 4),
                                   (3, 3, 2)],
                     relations=[(1, 1, 1, 2),
                                (1, 4, 2, 4),
                                (2, 2, 2, 3),
                                (3, 4, 4, 4),
                                (4, 5, 3, 5),
                                (4, 4, 5, 4),
                                (5, 5, 4, 5),
                                (5, 2, 5, 1)])

    s, f = genetic_solver(game=game,
                          generations=10000,
                          pop_size=100,
                          elitism=0.01,
                          crossover=0.8,
                          mutation=(0.05, 0.05))  # tuple of (rate, prob)

    print(s)
    print(f'Validation: {game.validate(s)}, fitness: {fitness(game, s)}')

    true_solution = [5, 1, 2, 3, 2, 5, 3, 1, 4, 4, 3, 5, 1, 3, 1, 5, 4, 2, 1, 2, 4, 3, 5]
    print(f'Validation: {game.validate(true_solution)}, fitness: {fitness(game, true_solution)}')

    worst_solution = [1 for i in range(23)]
    print(f'worst fitness: {fitness(game, worst_solution)}')

    # calibrate(game)


if __name__ == '__main__':
    main()
