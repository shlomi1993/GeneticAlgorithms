# Shlomi Ben-Shushan 311408264


from random import random, randint, shuffle, sample, choice
from copy import deepcopy
from futoshiki_stats import Statistics

stats = Statistics()


def sample_solution(game):
    return [randint(1, game.dim) for j in range(game.sol_size)]


def mutate(solution, rate, dim):
    global stats
    stats.mutate_calls += 1
    indexes = [i for i in range(len(solution))]
    chosen = sample(indexes, int(rate * len(solution)))
    for i in chosen:
        solution[i] = randint(1, dim)
    return solution


def cross_over(solution1, solution2):
    global stats
    stats.cross_over_calls += 1
    sep = randint(0, len(solution1) - 1)
    return solution1[:sep] + solution2[sep:]


def fitness(game, solution):
    global stats
    stats.fitness_calls += 1
    game.set(solution)
    score = game.n_constraints
    for x in range(game.dim):
        for y in range(game.dim):
            v = game.matrix[x][y]
            for i in range(game.dim):
                if i != x and game.matrix[i][y] == v:
                    score -= 1
                    break
            for j in range(game.dim):
                if j != y and game.matrix[x][j] == v:
                    score -= 1
                    break
    for a, b, c, d in game.relations:
        if game.matrix[a][b] <= game.matrix[c][d]:
            score -= 1
    return score


def optimize(game, solution, start_fitness):
    i = randint(0, len(solution) - 1)
    j = randint(1, game.dim)
    while solution[i] == j:
        j = randint(1, game.dim)
    new_solution = solution.copy()
    new_solution[i] = j
    new_fitness = fitness(game, new_solution)
    if new_fitness > start_fitness:
        return new_solution, new_fitness
    return solution, start_fitness


def genetic_solver(game, generations, pop_size, elitism, crossover, mutation,
                   optim=None):
    # Composition of the new population
    n_elite = int(elitism * pop_size)
    n_newborns = int(crossover * pop_size)
    n_survivors = pop_size - n_elite - n_newborns

    # Population
    population = [sample_solution(game) for i in range(pop_size)]

    # Statistics
    global stats
    stats = Statistics()
    stats.params = {
        'generations': generations,
        'population': pop_size,
        'elitism': elitism,
        'crossover': crossover,
        'mutation_prob': mutation[1],
        'mutation_rate': mutation[0],
        'optimization': optim
    }
    min_since_converged = []

    # Evolution
    chosen = ('', 0)
    for g in range(1, generations + 1):

        # Evaluation
        fitness_values = [fitness(game, s) for s in population]
        tuples = [(s, f) for s, f in zip(population, fitness_values)]

        # Gather information
        stats.generations += 1
        maximum = max(fitness_values)
        minimum = min(fitness_values)
        average = sum(fitness_values) / pop_size
        stats.min_fitness.append(minimum)
        stats.max_fitness.append(maximum)
        stats.avg_fitness.append(average)
        min_since_converged.append(minimum)

        # Optimization
        if optim == 'lamark':
            tuples = [optimize(game, s, f) for (s, f) in tuples]
        elif optim == 'darwin':
            darwin_tuples = [optimize(game, s, f) for (s, f) in tuples]
            darwin_chosen = max(darwin_tuples, key=lambda tup: tup[1])
            if chosen[1] < darwin_chosen[1]:
                chosen = deepcopy(darwin_chosen)

        # Sort solutions according to fitness and mark chosen one.
        tuples.sort(key=lambda tup: tup[1], reverse=True)
        if chosen[1] < tuples[0][1]:
            chosen = deepcopy(tuples[0])

        # Show information
        if g % 10 == 0:
            print(f'Generation {g}: '
                  f'Worst fitness: {minimum} | '
                  f'Average fitness: {average} | '
                  f'Best fitness: {maximum} | '
                  f'Chosen fitness: {chosen[1]} | '
                  f'Fitness calls: {stats.fitness_calls}')

        # Convergence test and handling
        if chosen[1] == game.n_constraints:
            print(f'Generation {g}: A legal solution has been found!')
            break
        if maximum == minimum:
            print(f'Generation {g}: CONVERGED! Restart calculations...')
            stats.restarts += 1
            min_since_converged.clear()
            for i in range(pop_size):
                ns = sample_solution(game)
                tuples[i] = (ns, fitness(game, ns))

        # Make bias array
        bias_array = []
        for i, (s, f) in zip(range(len(tuples)), tuples):
            for j in range(f):
                bias_array.append(i)
        shuffle(bias_array)

        # Elitism
        elites = [s.copy() for s, f in tuples[:n_elite]]

        # Cross-over
        newborns = []
        while len(newborns) < n_newborns:
            i, j = sample(bias_array, 2)
            (si, fi), (sj, fj) = tuples[i], tuples[j]
            s = cross_over(si, sj)
            f = fitness(game, s)
            if maximum == minimum or f > max(min_since_converged):
                newborns.append((s, f))

        # Replication
        survivors = []
        while len(survivors) < n_survivors:
            i = choice(bias_array)
            survivors.append(tuples[i])
            bias_array = list(filter(lambda k: k != i, bias_array))

        # Mutation
        non_elites = survivors + newborns
        mutated = []
        for s, f in non_elites:
            m = mutate(s.copy(), mutation[0], game.dim)
            if fitness(game, m) > f:
                mutated.append(m)
            else:
                mutated.append(m if random() < mutation[1] else s)

        # Create next generation
        population = elites + mutated

    stats.solution, stats.fitness = chosen
    return stats


def calibrate(game):
    elitism = [0.0, 0.01, 0.03, 0.05]
    crossover = [i * 0.1 for i in range(1, 10)]
    mutation = [(r, p * 0.01) for r in [0.05, 0.10] for p in range(1, 20, 2)]
    optim = [None, 'lamark', 'darwin']
    params = []
    for a in elitism:
        for b in crossover:
            for c in mutation:
                for d in optim:
                    st = genetic_solver(game, 3000, 100, a, b, c, d)
                    params.append(st)

    best = max(params, key=lambda s: s.fitness)
    corr = True if best.fitness == 58 else False
    best.print_stats(corr, game.matrix)
    return best


def debug():
    from futoshiki_game import Futoshiki
    game = Futoshiki(mat_size=5,
                     given_digits=[(1, 2, 4), (3, 3, 2)],
                     relations=[(1, 1, 1, 2), (1, 4, 2, 4), (2, 2, 2, 3),
                                (3, 4, 4, 4), (4, 5, 3, 5), (4, 4, 5, 4),
                                (5, 5, 4, 5), (5, 2, 5, 1)])

    st = genetic_solver(game=game,
                        generations=10000,
                        pop_size=100,
                        elitism=0.01,
                        crossover=0.8,
                        mutation=(0.05, 0.05),  # tuple of (rate, prob)
                        optim='')

    print(st.solution)
    print(f'Validation: {game.validate(st.solution)}, fitness: {st.fitness}')

    true_solution = [5, 1, 2, 3, 2, 5, 3, 1, 4, 4, 3, 5, 1, 3, 1, 5, 4, 2, 1, 2, 4, 3, 5]
    print(f'Validation: {game.validate(true_solution)}, fitness: {fitness(game, true_solution)}')


debug()
