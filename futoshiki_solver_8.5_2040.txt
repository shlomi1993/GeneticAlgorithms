# Shlomi Ben-Shushan 311408264


from random import randint, shuffle
from matplotlib import pyplot as plt


class Futoshiki:

    def __init__(self, mat_size, given_digits, relations):
        self.dim = mat_size
        self.matrix = [[0 for j in range(mat_size)] for i in range(mat_size)]
        self.given_digits = {}
        for (i, j, v) in given_digits:
            i = i - 1
            j = j - 1
            self.given_digits[(i, j)] = v
            self.matrix[i][j] = v
        self.sol_size = mat_size * mat_size - len(given_digits)
        self.higher_than = {}
        self.lower_than = {}
        for (i1, j1, i2, j2) in relations:
            p1 = (i1 - 1, j1 - 1)
            p2 = (i2 - 1, j2 - 1)
            if p1 in self.higher_than:
                self.higher_than[p1].append(p2)
            else:
                self.higher_than[p1] = [p2]
            if p2 in self.lower_than:
                self.lower_than[p2].append(p1)
            else:
                self.lower_than[p2] = [p1]

    def set(self, solution):
        k = 0
        for i in range(self.dim):
            for j in range(self.dim):
                if (i, j) not in self.given_digits.keys():
                    self.matrix[i][j] = solution[k]
                    k += 1

    def validate(self, solution):
        self.set(solution)
        for x in range(self.dim):
            for y in range(self.dim):
                v = self.matrix[x][y]
                for i in range(self.dim):
                    if i != x and self.matrix[i][y] == v:
                        return False
                for j in range(self.dim):
                    if j != y and self.matrix[x][j] == v:
                        return False
                p = (x, y)
                if p in self.higher_than:
                    lowers = self.higher_than[p]
                    for (i, j) in lowers:
                        if self.matrix[i][j] >= v:
                            return False
                if p in self.lower_than:
                    highers = self.lower_than[p]
                    for (i, j) in highers:
                        if self.matrix[i][j] <= v:
                            return False
                return True

    def reset(self):
        dim = len(self.matrix)
        for i in range(dim):
            for j in range(dim):
                if (i, j) not in self.given_digits.keys():
                    self.matrix[i][j] = 0


def mutate(solution, rate, dim):
    indexes = [i for i in range(len(solution))]
    shuffle(indexes)
    indexes = indexes[int(rate * len(solution)):]
    for i in indexes:
        solution[i] = randint(1, dim)
    return solution


def cross_over(solution1, solution2):
    sep = randint(0, len(solution1) - 1)
    co1 = solution1[:sep] + solution2[sep:]
    co2 = solution2[:sep] + solution1[sep:]
    return co1, co2


def fitness(game, solution):
    game.set(solution)
    hits = 0
    for x in range(game.dim):
        for y in range(game.dim):
            v = game.matrix[x][y]
            for i in range(game.dim):
                if i != x and game.matrix[i][y] == v:
                    hits += 1
            for j in range(game.dim):
                if j != y and game.matrix[x][j] == v:
                    hits += 1
            p = (x, y)
            v = game.matrix[x][y]
            if p in game.higher_than:
                lowers = game.higher_than[p]
                for (i, j) in lowers:
                    if game.matrix[i][j] >= v:
                        hits += 1
            if p in game.lower_than:
                highers = game.lower_than[p]
                for (i, j) in highers:
                    if game.matrix[i][j] <= v:
                        hits += 1
    return hits


# Policy:
# 1) Keep best
# 2) mutant p1 percent from the new generation.
# 3) p2 percent of the best cross-overing
def genetic_solver(game, generations, pop_size, p_mu, r_mu, p_co, threshold):

    population = [[randint(1, game.dim) for j in range(game.sol_size)] for i in range(pop_size)]
    min_fitness = []
    avg_fitness = []
    max_fitness = []
    fitness_calls = 0

    mu = int(p_mu * (len(population) - 1))
    co = int(p_co * (len(population) - 1))
    if co % 2 == 1:
        co -= 1

    elite = None
    for g in range(generations):

        # Calculate fitness
        fitness_values = [fitness(game, s) for s in population]
        minimum = min(fitness_values)
        average = sum(fitness_values) / len(population)
        maximum = max(fitness_values)
        min_fitness.append(minimum)
        avg_fitness.append(average)
        max_fitness.append(maximum)
        fitness_calls += len(population)

        # Tuple togather each solution and its fitness value.
        population_f = [(s, f) for s, f in zip(population, fitness_values)]

        # Divide solutions
        population_f.sort(key=lambda tup: tup[1])
        elite = population_f[0][0]

        # Convergence test
        if minimum == 0:
            return elite, fitness_calls

        # Choose random solutions
        others = [s[0] for s in population_f[1:]]
        indexes = list(range(0, len(others)))

        # Cross-over
        shuffle(indexes)
        co_indexes = indexes[:co]
        pairs = zip(co_indexes[0::2], co_indexes[1::2])
        for i, j in pairs:
            s1, s2 = cross_over(others[i], others[j])
            others[i] = s1
            others[j] = s2

        # Mutate
        shuffle(indexes)
        mu_indexes = indexes[:mu]
        for i in mu_indexes:
            others[i] = mutate(others[i], r_mu, game.dim)

        # Create the new generation
        population = [elite] + others

    plt.figure()
    plt.title('Fitness per generation')
    plt.xlabel('Generation')
    plt.ylabel('Fitness')

    x = list(range(len(min_fitness)))
    plt.plot(x, min_fitness, label='Minimal fitness')
    plt.plot(x, max_fitness, label='Maximal fitness')
    plt.plot(x, avg_fitness, label='Average fitness')
    plt.legend()
    plt.show()

    return elite, fitness_calls


def calibrate(game):
    generations = list(range(10, 1000, 10))
    pop_sizes = list(range(10, 500, 10))
    mut_percents = [i * 0.05 for i in range(20)]
    mut_rate = mut_percents.copy()
    co_percents = mut_percents.copy()
    thresholds = [i * 0.05 for i in range(20)]
    params = []
    for a in generations:
        for b in pop_sizes:
            for c in mut_percents:
                for d in mut_rate:
                    for e in co_percents:
                        for f in thresholds:
                            _, fitness_calls = genetic_solver(game, a, b, c, d, e, f)
                            params.append(((a, b, c, d, e, f), fitness_calls))
    return min(params, key=lambda tup: tup[1])[0]


def handle_convergence(game, generations, pop_size, p_mut, r_mut, p_co, threshold):
    solutions = []
    for i in range(10):
        s, f = genetic_solver(game, generations, pop_size, p_mut, r_mut, p_co, threshold)
        solutions.append((s, f))
    return min(solutions, key=lambda tup: tup[1])[0]


def main():
    game = Futoshiki(mat_size=5,
                     given_digits=[(1, 2, 4),
                                   (3, 3, 2)],
                     relations=[(1, 1, 1, 2),
                                (1, 4, 2, 4),
                                (2, 2, 2, 3),
                                (3, 4, 4, 4),
                                (4, 5, 3, 5),
                                (4, 4, 5, 4),
                                (5, 5, 4, 5),
                                (5, 2, 5, 1)])

    s, f = genetic_solver(game=game,
                          generations=100,
                          pop_size=100,
                          p_mu=1,
                          r_mu=0.1,
                          p_co=0.5,
                          threshold=3)


    print(s)
    print(f'Validation: {game.validate(s)}, fitness: {fitness(game, s)}')

    true_solution = [5, 1, 2, 3, 2, 5, 3, 1, 4, 4, 3, 5, 1, 3, 1, 5, 4, 2, 1, 2, 4, 3, 1]
    print(f'Validation: {game.validate(true_solution)}, fitness: {fitness(game, true_solution)}')

    # calibrate(game)
    # solver = GeneticSolver(game=game,
    #                        pop_size=100,
    #                        mut_percent=0.2,
    #                        mut_rate=0.2,
    #                        co_percent=0.2)
    # pop_size = 100
    # population = [[randint(1, 5) for j in range(game.sol_size)] for i in range(pop_size)]
    # for s, i in zip(solutions, range(1, len(solutions) + 1)):
    #     print('solutions.append(' + str(s) + ')')
    # solutions = [[2, 5, 3, 4, 1, 2, 4, 2, 5, 2, 2, 5, 4, 3, 2, 4, 4, 1, 4, 1, 1, 1, 3],
    #              [2, 5, 3, 5, 2, 2, 1, 3, 2, 1, 2, 1, 3, 3, 4, 3, 3, 3, 5, 4, 4, 4, 4],
    #              [4, 1, 4, 4, 5, 3, 1, 5, 2, 2, 4, 4, 1, 2, 2, 1, 2, 1, 1, 5, 4, 2, 4],
    #              [4, 5, 4, 2, 2, 1, 3, 3, 5, 3, 1, 4, 5, 5, 2, 2, 1, 2, 3, 5, 4, 4, 4],
    #              [4, 5, 4, 3, 2, 1, 1, 4, 5, 4, 1, 1, 2, 1, 5, 1, 3, 1, 3, 1, 1, 5, 4],
    #              [5, 2, 2, 2, 4, 4, 2, 5, 4, 5, 3, 5, 3, 2, 3, 5, 5, 4, 2, 4, 3, 3, 1],
    #              [2, 4, 2, 1, 3, 1, 2, 1, 2, 3, 4, 5, 2, 4, 2, 4, 1, 5, 2, 5, 4, 1, 4],
    #              [5, 3, 1, 3, 5, 1, 1, 2, 5, 5, 5, 5, 1, 3, 5, 5, 4, 1, 1, 2, 3, 5, 3],
    #              [5, 4, 1, 2, 2, 5, 5, 3, 4, 3, 2, 5, 2, 1, 3, 2, 4, 3, 2, 3, 5, 4, 2],
    #              [2, 4, 5, 4, 2, 4, 3, 4, 2, 1, 4, 1, 4, 4, 5, 4, 4, 4, 3, 4, 4, 4, 2],
    #              [2, 2, 1, 3, 3, 2, 2, 5, 1, 5, 2, 5, 2, 3, 2, 3, 3, 5, 3, 5, 3, 2, 3],
    #              [3, 4, 2, 1, 5, 1, 1, 4, 2, 4, 1, 2, 4, 4, 2, 2, 3, 3, 1, 1, 4, 5, 5],
    #              [2, 4, 1, 5, 3, 3, 1, 5, 4, 5, 3, 4, 1, 4, 2, 1, 3, 2, 1, 1, 4, 2, 1],
    #              [4, 4, 1, 4, 3, 3, 3, 1, 3, 2, 3, 3, 3, 5, 3, 4, 4, 1, 5, 5, 4, 3, 2],
    #              [3, 1, 3, 1, 2, 3, 4, 3, 3, 5, 5, 1, 2, 1, 5, 3, 1, 3, 1, 2, 4, 1, 2],
    #              [3, 4, 3, 1, 3, 4, 5, 4, 2, 1, 1, 3, 1, 4, 5, 4, 5, 3, 4, 2, 2, 4, 3],
    #              [4, 5, 3, 5, 2, 5, 3, 3, 2, 2, 5, 4, 1, 5, 4, 5, 4, 5, 5, 5, 4, 2, 1],
    #              [4, 5, 1, 5, 3, 4, 2, 5, 3, 3, 1, 5, 2, 1, 2, 5, 3, 1, 2, 2, 5, 2, 2],
    #              [1, 4, 3, 1, 4, 2, 5, 5, 2, 3, 2, 3, 1, 2, 3, 5, 5, 4, 5, 3, 2, 3, 5],
    #              [5, 3, 5, 5, 4, 3, 3, 5, 3, 1, 2, 1, 5, 1, 1, 5, 4, 5, 5, 3, 5, 5, 3]]
    # for s, i in zip(solutions, range(1, len(solutions) + 1)):
    #     print('sol' + str(i) + ' = ' + str(game.fitness(s)))
    # true_solution = [5, 1, 2, 3, 2, 5, 3, 1, 4, 4, 3, 5, 1, 3, 1, 5, 4, 2, 1, 2, 4, 3, 5]
    # print(true_solution, 'fitness:', game.fitness(true_solution))


if __name__ == '__main__':
    main()
